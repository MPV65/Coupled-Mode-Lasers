
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>singleSlab</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-04-16"><meta name="DC.source" content="singleSlab.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#4">Description</a></li><li><a href="#5">Usage</a></li><li><a href="#6">Arguments</a></li><li><a href="#7">Returns</a></li><li><a href="#8">Dependencies</a></li></ul></div><p><b>SINGLESLAB</b></p><h2 id="4">Description</h2><p>This routine calculates parameters for a single guide in the coupled mode model. Only the lowest even solution found is considered. In particular, the routine calculates the optical confinement factor, the effective index and the coupling coefficient for equal guides separated by a distance d.</p><p>The routine also returns the spatial profile of the mode and optionally plot this.</p><h2 id="5">Usage</h2><pre class="language-matlab">[GAA, eta, mode, neff] = singleInt(k0, n1, n2, w, d, varargin)
</pre><h2 id="6">Arguments</h2><pre class="language-matlab">k0          <span class="string">free</span> <span class="string">space</span> <span class="string">wavevector</span> <span class="string">(1/micron)</span>
n1          <span class="string">core</span> <span class="string">refractive</span> <span class="string">index</span>
n2          <span class="string">cladding</span> <span class="string">refractive</span> <span class="string">index</span>
w           <span class="string">guide</span> <span class="string">width</span> <span class="string">(micron)</span>
d           <span class="string">separation</span> <span class="string">between</span> <span class="string">guides</span> <span class="string">(micron)</span>
varargin    <span class="string">optional</span> <span class="string">argument.</span> <span class="string">If</span> <span class="string">passed</span> <span class="string">and</span> <span class="string">greater</span> <span class="string">than</span> <span class="string">0</span>, the
            routine <span class="string">reports</span> <span class="string">to</span> <span class="string">the</span> <span class="string">command</span> <span class="string">line</span> <span class="string">and</span> <span class="string">plots</span> <span class="string">a</span> <span class="string">graph</span> <span class="string">of</span>
            the <span class="string">mode.</span>
</pre><h2 id="7">Returns</h2><pre class="language-matlab">GAA         <span class="string">the</span> <span class="string">optical</span> <span class="string">confinement</span> <span class="string">factor</span> <span class="string">for</span> <span class="string">the</span> <span class="string">guide</span>
eta         <span class="string">the</span> <span class="string">coupling</span> <span class="string">coefficient</span> <span class="string">for</span> <span class="string">equal</span> <span class="string">guides</span> <span class="string">separated</span> <span class="string">by</span> <span class="string">d</span>
mode        <span class="string">2</span> <span class="string">x</span> <span class="string">10001</span> <span class="string">array</span> <span class="string">containing:</span>
                mode(1,:) - spatial coordinates
                mode(2,:) - mode profile
neff        <span class="string">the</span> <span class="string">effective</span> <span class="string">refractive</span> <span class="string">index</span>
</pre><h2 id="8">Dependencies</h2><pre class="language-matlab">This <span class="string">routine</span> <span class="string">calls:</span>
</pre><pre>     bisect          bisection routine*
     trapezoid1D     1D integration routine*</pre><pre class="language-matlab">*Note that <span class="string">both</span> <span class="string">bisect</span> <span class="string">and</span> <span class="string">trapezoid</span> <span class="string">are</span> <span class="string">in</span> <span class="string">the</span> <span class="string">'Numeric'</span> <span class="string">directory.</span>
The <span class="string">routine</span> <span class="string">checks</span> <span class="string">to</span> <span class="string">see</span> <span class="string">if</span> <span class="string">this</span> <span class="string">are</span> <span class="string">on</span> <span class="string">the</span> <span class="string">path</span> <span class="string">and</span> <span class="string">if</span> <span class="string">not</span>, attempts
to <span class="string">add</span> <span class="string">it.</span> <span class="string">For</span> <span class="string">this</span> <span class="string">to</span> <span class="string">work</span>, the <span class="string">'Numeric'</span> <span class="string">directory</span> <span class="string">MUST</span> <span class="string">be</span> <span class="string">in</span> <span class="string">a</span>
folder <span class="string">called</span> <span class="string">'Photonic-Neurons'</span>, which <span class="string">should</span> <span class="string">be</span> <span class="string">on</span> <span class="string">the</span> <span class="string">MATLAB</span> <span class="string">path</span>
</pre><pre>     'C:\Users\&lt;user_name&gt;\Documents\MATLAB'</pre><pre class="language-matlab">or <span class="string">similar.</span> <span class="string">Type</span> <span class="string">'userpath'</span> <span class="string">at</span> <span class="string">the</span> <span class="string">command</span> <span class="string">line</span> <span class="string">to</span> <span class="string">check.</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
function [GAA, eta, mode, neff] = singleSlab(k0, n1, n2, w, d, varargin)
%SINGLESLAB Calculates parameters for a single slab guide in the coupled mode model. 
%%
% *SINGLESLAB*
%
%%  Description
%
% This routine calculates parameters for a single guide in the coupled mode 
% model. Only the lowest even solution found is considered. In particular,
% the routine calculates the optical confinement factor, the effective
% index and the coupling coefficient for equal guides separated by a
% distance d. 
%
% The routine also returns the spatial profile of the mode and optionally
% plot this.
% 
%%  Usage
%
%   [GAA, eta, mode, neff] = singleInt(k0, n1, n2, w, d, varargin)
%
%%  Arguments
%
%   k0          free space wavevector (1/micron)
%   n1          core refractive index
%   n2          cladding refractive index
%   w           guide width (micron)
%   d           separation between guides (micron)
%   varargin    optional argument. If passed and greater than 0, the
%               routine reports to the command line and plots a graph of
%               the mode.
%
%%  Returns
%
%   GAA         the optical confinement factor for the guide
%   eta         the coupling coefficient for equal guides separated by d
%   mode        2 x 10001 array containing:
%                   mode(1,:) - spatial coordinates
%                   mode(2,:) - mode profile
%   neff        the effective refractive index
%
%%  Dependencies
%
%   This routine calls:
%
%       bisect          bisection routine*
%       trapezoid1D     1D integration routine*
%   
%   *Note that both bisect and trapezoid are in the 'Numeric' directory.
%   The routine checks to see if this are on the path and if not, attempts
%   to add it. For this to work, the 'Numeric' directory MUST be in a
%   folder called 'Photonic-Neurons', which should be on the MATLAB path
%
%       'C:\Users\<user_name>\Documents\MATLAB'  
%
%   or similar. Type 'userpath' at the command line to check.
%
%%

    % Boolean to indicate whether routine reports and plots results
    report = false;
    xspan = 9.0*w;
    c = 299792458E-3; % micron/ns

    precision = 1E-9;

    if (nargin > 5)

        if (varargin{1} > 0)
            report = true;
        end


    end

    % If profile is anti-guiding, report an error
    if (n1 <= n2)

        error('Index profile is anti-guiding (n1 <= n2)');

    end

    % Calls bisect - check if this is present on the path!
    if (exist('bisect','file') ~= 2)

        % Folder containing bisect.m
        addpath([userpath '/Photonic-Neurons/Numeric']); 

    end

    maxb = n1*k0;
    minb = n2*k0;
    npts = 10001;

    db = (maxb - minb)/(npts - 1);
    beta = minb:db:maxb;

    % Construct array of intervals for even solutions
    %
    % feven returns the function f(beta) = tan(kappa*w/2) - gamma/kappa, 
    % where
    %
    %   gamma = sqrt(beta^2- n2^2*k0^2)
    %
    %   kappa = sqrt(n1^2*k0^2 - beta^2)
    %
    % The even solutions are given for beta when f(beta) = 0.
    %
    % NOTE that f(beta) decreases monotonically between singularities, 
    % where it flips from -inf to +inf
    fev = feven(beta, k0, n1, n2, w);

    % Start with first element of fev...
    fev1 = fev(1);

    % ... see if it is less than zero
    if (fev1 < 0)

        % If it is, we are in a region where f(beta) is negative
        x1 = -1;    

    else

        % Otherwise, f(beta) is positive
        x1 = 1;     
    end

    neven = 0;                 % Number of zeros
    evenints = zeros(npts, 2); % Array for intervals

    for n = 2:npts

        % Get next element of fev
        fevn = fev(n);

        if (fevn < 0)

            x2 = -1;    % In a region where f(beta) is negative

        else

            x2 = 1;     % In a region where f(beta) is positive

        end

        % Test if we have moved from a positive region to a negative one
        % Note that f(beta) decreases monotonically except at singular 
        % points where it flips from -inf to +inf.
        if ((x1 == 1)&&(x2 == -1))

            % If so, increment the number of solutions...
            neven = neven + 1;  

            evenints(neven, 1) = beta(n-1); % ... and store interval
            evenints(neven, 2) = beta(n);

        end

        % Set first point to previous second point
        x1 = x2;

    end

    if (neven == 0)

        error('No even solutions found');

    end

    evensols = zeros(1, neven);

    % Solve for beta on each of the solution intervals
    for n = 1:neven

        % Even solution
        beta1 = evenints(n, 1);
        beta2 = evenints(n, 2);
        % Anonymous function handle
        func = @(beta) feven(beta, k0, n1, n2, w); 
        [beta_even, OK] = bisect(func, beta1, beta2, precision); 

        if (OK)

            evensols(n) = beta_even;

        else

            error(['Invalid integral for ' num2str(n) ' even solution']);

        end


    end

    % Find highest value of beta (this will be the lowest even mode)
    beta_even = max(evensols);
    neff = beta_even/k0;

    % Construct solutions
    xmax = xspan/2.0;
    xmin = -xmax;
    npts = 10001;
    dx = (xmax - xmin)/(npts - 1.0);
    x = xmin:dx:xmax;

    mode = zeros(2, length(x));
    mode(1,:) = x;

    guide = (x >= -w/2.0)&(x <= w/2.0);

    psiA = evensol(x, beta_even, k0, n1, n2, w);
    % Shifted second guide
    psiB = evensol(x+d+w, beta_even, k0, n1, n2, w);    

    % Intensity
    I = psiA.*psiA;

    % Normalise intensity
    A2 = trapezoid1D(x, I);

    % Normalisation constant
    N = 1.0/sqrt(A2); 
    psiA = N*psiA;
    psiB = N*psiB;

    mode(2,:) = psiA;

    IAA = psiA.*psiA.*guide;
    GAA = trapezoid1D(x, IAA);

    IAB = psiA.*psiB.*guide;
    GAB = trapezoid1D(x, IAB);

    eta = (c*k0/(2.0*n1^2))*(n1^2 - n2^2)*GAB;

    % Analytical expression for the coupling coefficient
%     Wr = 1.26;
%     Cn = 83.6;                  % (ns^-1)
%     eta2 = Cn*exp(-2.0*Wr*d/w);  % Coupling coefficent (absolute value)
% 
%     a = w/2.0;
% 
%     W = a*gamma(beta_even, k0, n2);
%     U = a*kappa(beta_even, k0, n1);
%     V = a*k0*sqrt(n1^2 - n2^2);
% 
%     Cn2 = (c/(k0*n1^2))*(U*W/(a*V))^2/(W+1.0);
%     eta3 = Cn2*exp(-2.0*W*d/w);

    if (report)

        lw = 2;
        gw = 0.2;

        figure;
        plot(x, gw*guide, 'kREPLACE_WITH_DASH_DASH', 'LineWidth', lw);
        title('Single guide solutions');
        ylabel('\psi');
        xlabel('x');
        grid on;
        hold on;
        plot(x, psiA, 'LineWidth', lw);

        disp(' ');
        disp(['k0 = ' num2str(k0) ' microns^(-1)']);
        disp(['n1 = ' num2str(n1,9)]);
        disp(['n2 = ' num2str(n2,9)]);
        disp(['d = ' num2str(d) ' microns']);
        disp(['w = ' num2str(w) ' microns']);
        disp(' ');
        disp(['GAA = ' num2str(GAA)]);
%         disp(['GAB = ' num2str(GAB)]);
        disp(['neff = ' num2str(neff)]);
        disp(['eta = ' num2str(eta)]);
%         disp(['eta2 = ' num2str(eta2)]);
%         disp(['eta3 = ' num2str(eta3)]);
%         disp(['Wr = ' num2str(Wr)]);
%         disp(['W = ' num2str(W)]);
%         disp(['Cn = ' num2str(Cn)]);
%         disp(['Cn2 = ' num2str(Cn2)]);

    end

    % Local functions

    function r = feven(beta, k0, n1, n2, w)
        % Argument of tan function in functions to solve
        k = kappa(beta, k0, n1);
        g = gamma(beta, k0, n2);
        
        r = tan(k*w/2) - g./k;
        
    end

    function r = kappa(beta, k0, n1)
        % Effective wavevector
        r = sqrt(n1*n1*k0*k0 - beta.*beta);
        
    end

    function r = gamma(beta, k0, n2)
        % Effective wavevector
        r = sqrt(beta.*beta - n2*n2*k0*k0);
        
    end

    % Functions to construct solutions
        
    function psi = evensol(x, beta, k0, n1, n2, w)
        
        % Effective wavevectors
        k2 = n1*n1*k0*k0 - beta*beta;
        g2 = beta*beta - n2*n2*k0*k0;
        
        k = sqrt(k2);
        g = sqrt(g2);
        
        B0 = exp(-g*w/2.0)/cos(k*w/2.0);
        
        % Masks for different regions
        m1 = (x < -w/2.0);
        m2 = (x >= -w/2.0)&(x <= w/2.0);
        m3 = (x > w/2.0);
        
        psi1 = exp(g*x).*m1;
        psi2 = B0*cos(k*x).*m2;
        psi3 = exp(-g*x).*m3;
        
        psi = psi1 + psi2 + psi3;
        
    end

end


##### SOURCE END #####
--></body></html>